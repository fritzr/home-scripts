#!/bin/bash
# Start a ChangeLog entry with the date and my author info

test -z "$NAME" && NAME=$(git config --get --global user.name)
test -z "$NAME" && NAME=$(git config --get --file ~/.gitconfig.local user.name)
test -z "$NAME" && read -e -p "NAME? " NAME
test -z "$NAME" && exit 2

test -z "$EMAIL" && EMAIL=$(git config --get --global user.email)
test -z "$EMAIL" \
  && EMAIL=$(git config --get --file ~/.gitconfig.local user.email)
test -z "$EMAIL" && read -e -p "EMAIL? " EMAIL
test -z "$EMAIL" && exit 2

if [ -z "$EDITOR" ]; then
  EDITOR="$(which vim)"
fi

function usage() {
  echo "Usage: $(basename $0) PATCH" >&2
  echo "Prepare the gcc-svn tree to commit PATCH." >&2
  echo "Note the PATCH should have been exported by 'git format-patch'." >&2
  echo $1 >&2
  exit 1
}

if [ $# -ne 1 ]; then
  usage
fi

patch=$(readlink -f "$1")
if [ ! -r "$patch" ]; then
  usage "error: [...]/$(basename $patch): Bad patch file."
fi

if [ ! -d gcc/fortran -o ! -d gcc/testsuite/gfortran.dg -o ! -d libgfortran ];
then usage "error: not in a gcc root"
fi

function verbose_rm() {
  while read i; do
    if [ -f "$i" ]; then
      echo "Removing '$i'"
      rm -f "$i"
    elif [ -d "$i" ]; then
      echo -n "Remove '$i' recursively? "
      rm -rI "$i" &>/dev/null
    fi
  done
}

# Revert modified files, remove newly added files, force update
svn status | grep '^[A?]' | cut -d' ' -f2- | xargs echo | verbose_rm \
  && svn revert -R gcc/fortran gcc/testsuite libgfortran \
  && svn update
test $? -ne 0 && echo "UPDATE FAILED, try again" && exit 2

# Grab message and author from patch file
author=$(grep '^From:' $patch | cut -d' ' -f2-)
test -z "$author" && author="$NAME  $EMAIL"

log_head=$(date +"%Y-%m-%d  $author")

diff_tmp=$(mktemp -q)
commit_tmp=$(mktemp -q)

# Split pieces of commit message into separate files
ft_cl=gcc/fortran/ChangeLog
dg_cl=gcc/testsuite/ChangeLog
lb_cl=libgfortran/ChangeLog
ft_tmp=$(mktemp -q)
dg_tmp=$(mktemp -q)
lb_tmp=$(mktemp -q)
add_tmp=$(mktemp -q)
pr_tmp=$(mktemp -q)

CLEANUP="rm -f $commit_tmp $ft_tmp $dg_tmp $lb_tmp $diff_tmp $add_tmp"
trap "$CLEANUP" EXIT

cat <<EOF | perl -w -MIO::File -n - $patch || exit 2
BEGIN {
  \$ft  = IO::File->new("$ft_tmp", "w");
  \$dg  = IO::File->new("$dg_tmp", "w");
  \$lb  = IO::File->new("$lb_tmp", "w");
  \$nil = IO::File->new("/dev/null", "w");
  \$df  = IO::File->new("$diff_tmp", "w");
  \$add = IO::File->new("$add_tmp", "w");
  \$pr  = IO::File->new("$pr_tmp", "w");
  \$current = \$nil;
  \$message = 0;
  \$diff = 0;
}

  \$line = \$_;
  if (\$message == 0 && \$diff == 0 && \$line =~ / ([^ ]+)[^|]+\\|[^+]+\\+/) {
    \$add->print(\$1 . " ");
  }
  if (\$line =~ /^---/) {
    \$current->print("\\n");
    \$current=\$nil;
    \$message=0;
  }

  if (\$line =~ /^diff/)        { \$diff=1; }
  if (\$diff == 1)    { \$df->print(\$line); }
  if (\$message == 1) {

    if (\$line =~ /^[ \\t]*PR.*/) {
      \$pr->print(\$line);
    }

    else {
      if (\$line =~ /gcc\\/fortran/) {
        \$current=\$ft;
        if (\$line !~ /gcc\\/fortran[\\/\\t ]*$/) {
          \$current->print(\$line);
        }
      }

      elsif (\$line =~ /gfortran.dg/) {
        \$current=\$dg;
        \$line =~ s/gcc\\/testsuite\\///;
        \$current->print(\$line);
      }

      elsif (\$line =~ /libgfortran\\//) {
        \$current=\$lb;
        if (\$line !~ /libgfortran[\\/\\t ]*$/) {
          \$current->print(\$line);
        }
      }

      else {
        \$current->print(\$line);
      }
    }
  }
  if (\$line =~ /^Subject[^\\]]+\\] *(.*)$/) {
    \$message=1;
  }

END {
  \$ft->close();
  \$dg->close();
  \$lb->close();
  \$df->close();
  \$add->close();
  \$pr->close();
}
EOF

# Apply patch
patch -N --no-backup-if-mismatch -p1 < $diff_tmp
test $? -ne 0 && echo "PATCH FAILED, try again" >&2 && exit 2

# Sort and trim PRs
if [ -s "$pr_tmp" ]; then
  cat $pr_tmp | sort | uniq > ${pr_tmp}2 && mv ${pr_tmp}2 $pr_tmp
fi

# Prepend PRs and log messages to appropriate changelogs
for ftype in ft dg lb; do
  tmp=${ftype}_tmp; tmp=${!tmp}
  cl=${ftype}_cl; cl=${!cl}
  if [ -s $tmp ]; then
    if [ -s "$pr_tmp" ]; then
      cat $pr_tmp | prepend $tmp
    fi
    sed -i "s/        /\t/g" $tmp
    ( echo -e "$log_head\n" | prepend $tmp ) && prepend $tmp $cl
    echo ">>>> $cl <<<<"
    cat $tmp
    echo "=============================="
  fi
done

# clogcat <changelog-name> <changelog-path>
# cat the changelog, prefixed by a message with its name
function clogcat() {
  if [ -s "$2" ]; then
    echo "    $1:"
    echo ""
    clog-head $2 | sed '1,2d'
  fi
}

### Build the commit message
function commit_msg() {
  echo "$log_head"
  echo ""

  # the PR(s), if any
  if [ -s "$pr_tmp" ]; then
    cat $pr_tmp | sed 's/\t/    /'
    echo ""
  fi

  # the changelogs, if any
  clogcat $ft_cl $ft_tmp
  clogcat $dg_cl $dg_tmp
  clogcat $lb_cl $lb_tmp
}

commit_msg > "$commit_tmp"

# Dump commit message.
echo ">>>> COMMIT MESSAGE <<<<"
cat $commit_tmp
echo "=============================="

echo "* status:"
cat $add_tmp | xargs svn add -q
svn status

# Verify commit.
read -e -p "Commit? [y/N/e] > " do_commit
test -z "$do_commit" -o "$do_commit" = "N" -o "$do_commit" = "n" \
  && exit 1

if [ "$do_commit" = "e" -o "$do_commit" = "E" ]; then
  $EDITOR $commit_tmp
fi

test $? -eq 0 -a -s "$commit_tmp" \
  && echo "committing!" && svn commit -F $commit_tmp

exit $?
